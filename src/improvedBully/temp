    # higherNodes = [n for n in knownNodes if n > self.id]
    # if not higherNodes:
    #   self.setCurrentLeader()
    #   return



    # # Send ELECTION messages to highest node first and wait for reply
    # while self.status == "Election":
    #   highestNode = max(higherNodes)
    #   print(f"Node {self.id} sending ELECTION to Node {highestNode}.")
    #   self.sendMessage(highestNode, Message("ELECTION", self.id, highestNode))

    #   # Wait for OK or COORDINATOR messages
    #   print(
    #       f"Node {self.id} waiting for OK or COORDINATOR message from Node {highestNode}...")

    #   timeout = 1
    #   event_set = self.electionEvent.wait(timeout=timeout)

    #   with self.stateLock:
    #     event_set = self.electionEvent.wait(timeout=timeout)
    #     # Check 1: Did we receive a COORDINATOR message?
    #     if self.leaderId is not None:
    #       print(
    #           f"Node {self.id} received COORDINATOR message from Node {self.leaderId}.")
    #       self.status = "Normal"
    #       return

    #     # Check 2: Did we receive any OK messages?
    #     if self.receivedOk:
    #       print(
    #           f"Node {self.id} received OK messages, waiting for COORDINATOR.")
    #       self.status = "Normal"
    #       return

    #     # Check 3: Timeout reached without any OK or COORDINATOR messages
    #     print(
    #         f"Node {self.id} did not receive any OK message or COORDINATOR within timeout.")

    #     # Send ELECTION to next highest node
    #     higherNodes.remove(highestNode)

    #     if higherNodes:
    #       continue

    #     else:
    #       # No more higher nodes, declare self as leader
    #       self.setCurrentLeader()
    #       self.status = "Normal"
    #       return